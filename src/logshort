#!/usr/bin/awk -f
# stdin : logfile
# stdout : copy replacing consecutive stable lines by a single placeholder
# Comparison is done not by character but by word
# Synopsis : $myname [ argscore=number ] [ argsep=regexp ] [ argntail=number ]
# argscore = min stability score, default 0.85
# argsep = word separator, default "[-:;=/ \[\],{}()]+"
# argntail = max number of lines in single match, default 10

BEGIN {
  if (argscore == "") argscore = 0.85
  if (argsep == "") argsep = "[-:;=/ \\[\\],{}()]+"
  if (argntail == "") argntail = 10
  delete tail_sizes[0]
  delete tail_words[0]
}

# append e to tail,
# keep tail size below depth by outshifting left items,
# return sum of outshifted items
function tailput(tail, e, depth,
  l, f, el, result) {
  l = alength(tail)
  el = alength(e)
  f = depth - el - l
  if (f > 0) {
    f = 0
  }
  for (i = 1; i <= l; i++) {
    f++
    if (f <= 0) {
      result += tail[1-f]
    } else if (f <= depth && f < i) {
      tail[f] = tail[i]
    }
  }
  for (i = 1; i <= el; i++) {
    f++
    if (f <= 0) {
      result += tail[1-f]
    } else if (f <= depth) {
      tail[f] = e[i]
    }
  }
  for (i = depth + 1; i <= l; i++) {
    delete tail[i]
  }
  return result
}

function tailputx(tail, x, depth,
  e) {
  e[1] = x
  return tailput(tail, e, depth)
}

# erase array
function raz(to) {
  for (i in to) {
    delete to[i]
  }
}

# copy array
function arraycopy(from, to) {
  raz(to)
  for (i in from) {
    to[i] = from[i]
  }
}

# rotate array
function leftrotate(from, rotate,
  l, x, j) {
  l = alength(from)
  if (rotate % l != 0) {
    arraycopy(from,x)
    for (i = 1; i <= l; i++) {
      j = (i + rotate - 1) % l + 1
      from[i] = x[j]
    }
  }
}

# array length (not builtin in mawk)
function alength(from,
  result) {
  for (i in from) {
    result++
  }
  return result
}

# Compare contiguous right parts of array a, of length rightin,
# neweq maps {false,true} to each {different,equal} element and must be erased
# before call when we want a new comparison without stability history.
# return stability score [0-1]
function cmp_with_history(a, rightin, neweq,
  stabq, result, beq, left, right) {
  arraycopy(neweq, stabq)
  raz(neweq)
  right = alength(a) - rightin
  left = right - rightin
  if (left >= 0) {
    for (i = 1; i <= rightin; i++) {
      neweq[i] = beq = i <= rightin && ((!(i in stabq)) || stabq[i]) && a[i + left] == a[i + right]
      if (beq) {
        result++
      }
    }
    if (i > 1) {
      return result / (i-1)
    }
  }
}

function breakdiff(e){
  if (nseq > 0) {
    if (nseq > 1) {
      print "==== "nseq" consecutive "int(pre_score * 100)"% matching "pre_window / 2"*lines ===="
    } else {
      print pre_line
    }
    nseq = 0
  }
}

{
  lwordsin = split($0, words, argsep)
  score = 0
  tailput(tail_words, words, alength(tail_words) + lwordsin - tailputx(tail_sizes, lwordsin, argntail*2))
  lsizes = alength(tail_sizes)
  if (nseq == 0) {
    right = both = 0
    for (window = 2; window <= lsizes && score < argscore; window += 2) {
      right = right + tail_sizes[lsizes + 1 - (window / 2)]
      both = both + tail_sizes[lsizes - window + 1] + tail_sizes[lsizes - window + 2]
      left = both - right
      raz(eqwords)
      if (left == right) {
        score = cmp_with_history(tail_words, right, eqwords)
      }
    }
  } else {
    right = right + lwordsin - tail_sizes[lsizes - (pre_window / 2)]
    if (left == right) {
      leftrotate(eqwords, lwordsin)
      score = cmp_with_history(tail_words, right, eqwords)
    }
    if (score < argscore) {
      for ( ; window <= lsizes && score < argscore ; window += 2) {
        right = right + tail_sizes[lsizes + 1 - (window / 2)]
        both = both + tail_sizes[lsizes - window + 1] + tail_sizes[lsizes - window + 2]
        left = both - right
        raz(eqwords)
        if (left == right) {
          score = cmp_with_history(tail_words, right, eqwords)
        }
      }
    }
  }
  if (score >= argscore) {
    pre_score = score
    pre_line = $0
    pre_window = window - 2
    nseq++
  } else {
    breakdiff()
    print
  }
}

END {
  breakdiff()
}
